<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ege Cirakman">
<meta name="author" content="Huseyin Tuna Erdinc">
<meta name="author" content="Felix J. Herrmann">

<title>Efficient and scalable posterior surrogate for seismic inversion via wavelet score-based generative models</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script src="site_libs/quarto-contrib/SLIM/SLIM.min.js"></script>
<link href="site_libs/quarto-contrib/SLIM/ScholarlyMarkdown-forMarked-latest.css" rel="stylesheet">
<script src="site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Efficient and scalable posterior surrogate for seismic inversion via wavelet score-based generative models</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/slimgroup"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#theory" id="toc-theory" class="nav-link" data-scroll-target="#theory">Theory</a>
  <ul class="collapse">
  <li><a href="#seismic-imaging" id="toc-seismic-imaging" class="nav-link" data-scroll-target="#seismic-imaging">Seismic imaging</a></li>
  <li><a href="#sbi-for-posterior-estimation" id="toc-sbi-for-posterior-estimation" class="nav-link" data-scroll-target="#sbi-for-posterior-estimation">SBI for posterior estimation</a></li>
  <li><a href="#score-based-generative-models-sgms-and-wsgm" id="toc-score-based-generative-models-sgms-and-wsgm" class="nav-link" data-scroll-target="#score-based-generative-models-sgms-and-wsgm">Score-based generative models (SGMs) and WSGM</a></li>
  <li><a href="#training-objective-and-conditional-wsgm" id="toc-training-objective-and-conditional-wsgm" class="nav-link" data-scroll-target="#training-objective-and-conditional-wsgm">Training objective and conditional WSGM</a></li>
  </ul></li>
  <li><a href="#experiments-and-results" id="toc-experiments-and-results" class="nav-link" data-scroll-target="#experiments-and-results">Experiments and Results</a>
  <ul class="collapse">
  <li><a href="#dataset-creation" id="toc-dataset-creation" class="nav-link" data-scroll-target="#dataset-creation">Dataset creation</a></li>
  <li><a href="#inference-results" id="toc-inference-results" class="nav-link" data-scroll-target="#inference-results">Inference results</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="abstract.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./abstract.html">Abstracts</a></li><li class="breadcrumb-item"><a href="./abstract.html">Wavelet Score-Based Generative Models</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Efficient and scalable posterior surrogate for seismic inversion via wavelet score-based generative models</h1>
</div>


<div class="quarto-title-meta-author column-page-left">
  <div class="quarto-title-meta-heading">Authors</div>
  <div class="quarto-title-meta-heading">Affiliations</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author">Ege Cirakman </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Istanbul Technical University
          </p>
      </div>
    <div class="quarto-title-meta-contents">
    <p class="author">Huseyin Tuna Erdinc </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Georgia Institute of Technology
          </p>
      </div>
    <div class="quarto-title-meta-contents">
    <p class="author">Felix J. Herrmann </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Georgia Institute of Technology
          </p>
      </div>
  </div>

<div class="quarto-title-meta column-page-left">

      
  
    
  </div>
  
<div>
  <div class="abstract">
    <div class="block-title">Abstract</div>
    Seismic inversion poses significant computational challenges due to its high dimensionality and non-unique solutions. We propose a novel method integrating the Wavelet Score-Based Generative Model (WSGM) with Simulation-Based Inference (SBI) to enable efficient posterior sampling for full-waveform inference. Our approach reduces memory requirements (<span class="math inline">\(\approx 50\%\)</span>) and significantly decreases sampling time (<span class="math inline">\(\approx 73\%\)</span>) compared to standard score-based diffusion models, while preserving accuracy. Furthermore, WSGM naturally supports the generation of velocity models at multiple resolutions, leveraging its hierarchical structure. Experimental results on pairs of synthetic seismic images and velocity models demonstrate that our method enables posterior sampling for large-scale 2D geophysical problems and facilitates the assessment of uncertainties relevant to subsurface characterization.
  </div>
</div>


</header>


<div class="hidden">
<p><span class="math display">\[
\def\textsc#1{\dosc#1\csod}
\def\dosc#1#2\csod{{\rm #1{\small #2}}}
\]</span></p>
</div>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Accurate subsurface characterization remains a fundamental challenge in geophysical exploration, with seismic inversion serving as the primary tool for reconstructing subsurface properties, such as the acoustic wave-speed. The inverse problem of estimating velocity models from seismic observations is inherently ill-posed due to its high dimensionality, non-uniqueness and sensitivity to noise <span class="citation" data-cites="virieux2009overview Tarantola2005InverseProblemTheory">(<a href="#ref-virieux2009overview" role="doc-biblioref">Virieux and Operto 2009</a>; <a href="#ref-Tarantola2005InverseProblemTheory" role="doc-biblioref">Tarantola 2005</a>)</span>. As noted in the literature, traditional methods such as full-waveform inversion (FWI), that rely on point estimates, fail to capture the full uncertainty of the problem and do not produce posterior distributions, which is essential for informed decision-making in reservoir characterization and management <span class="citation" data-cites="siahkoohi2022deep fichtner2013multiscale XIAO2025112160">(<a href="#ref-siahkoohi2022deep" role="doc-biblioref">Siahkoohi, Rizzuti, and Herrmann 2022</a>; <a href="#ref-fichtner2013multiscale" role="doc-biblioref">Fichtner and Trampert 2013</a>; <a href="#ref-XIAO2025112160" role="doc-biblioref">Xiao and Fichtner 2025</a>)</span>.</p>
<p>Recent advances in machine learning have introduced promising algorithms to develop neural surrogates for posterior distributions. Specifically, SBI can facilitate posterior approximation of posterior <span class="math inline">\(p(\mathbf{x} \mid \mathbf{y})\)</span> in Bayesian inference without explicit evaluation of the costly likelihood/simulator, in our case directly related to the creation of subsurface images <span class="citation" data-cites="cranmer2020frontier">(<a href="#ref-cranmer2020frontier" role="doc-biblioref">Cranmer, Brehmer, and Louppe 2020</a>)</span>. SBI can be implemented using various types of generative models, such as conditional normalizing flows <span class="citation" data-cites="normalizing_flow">(<a href="#ref-normalizing_flow" role="doc-biblioref">Papamakarios et al. 2021</a>)</span> or score-based generative models <span class="citation" data-cites="song2020score">(<a href="#ref-song2020score" role="doc-biblioref">Y. Song et al. 2020</a>)</span>, each with its own strengths and weaknesses. However, we observe that most of the existing generative modeling approaches often overlook the multiscale structure and long-range spatial correlations inherent in subsurface velocity models <span class="citation" data-cites="rizzuti2024multiscale">(<a href="#ref-rizzuti2024multiscale" role="doc-biblioref">Rizzuti, Siahkoohi, and Herrmann 2024</a>)</span>.</p>
<p>Based on this insight, we propose a conditional variation of WSGM <span class="citation" data-cites="guth2022waveletscorebasedgenerativemodeling">(<a href="#ref-guth2022waveletscorebasedgenerativemodeling" role="doc-biblioref">Guth and Bruna 2022</a>)</span> within the SBI framework to perform posterior estimation for velocity inversion from seismic images. Our approach leverages Daubechies (db2) wavelets to decompose the posterior across multiple resolution scales (32$<span class="math inline">\(32 to 256\)</span>$256), enabling hierarchical modeling and formulation of scale-specific score functions. This multi-scale factorization maintains consistency between observations and velocity estimates across resolutions, while reducing computational requirements compared to standard diffusion methods.</p>
<p>The key contributions of this paper are as follows: (i) the introduction of conditional WSGM for posterior sampling in seismic inversion, (ii) a cascaded network architecture designed to reduce memory consumption, (iii) comprehensive experiments on synthetic datasets demonstrating superior performance in reconstructing complex velocity structures, and (iv) the generation of uncertainty estimates that correlate well with errors. The remainder of the paper is organized as follows: we present the theory, describe the experimental setup, and discuss the results, establishing WSGM as an efficient and scalable approach for probabilistic seismic inversion.</p>
</section>
<section id="theory" class="level1">
<h1>Theory</h1>
<section id="seismic-imaging" class="level2">
<h2 class="anchored" data-anchor-id="seismic-imaging">Seismic imaging</h2>
<p>Seismic imaging aims to reconstruct a velocity model <span class="math inline">\(\mathbf{x} \in \mathbb{R}^n\)</span> from seismic observations <span class="math inline">\(\mathbf{y} \in \mathbb{R}^m\)</span> recorded at the surface, governed by the forward model <span class="math inline">\(\mathbf{y} = \mathbf{\mathcal{F}}(\mathbf{x}) + \boldsymbol{\epsilon}\)</span>, where <span class="math inline">\(\mathbf{\mathcal{F}}: \mathbb{R}^n \rightarrow \mathbb{R}^m\)</span> is a nonlinear operator solving the wave equation and <span class="math inline">\(\boldsymbol{\epsilon}\)</span> represents noise <span class="citation" data-cites="virieux2009overview">(<a href="#ref-virieux2009overview" role="doc-biblioref">Virieux and Operto 2009</a>)</span>. The inverse problem is ill-posed, non-uniqueness (e.g., <span class="math inline">\(\mathbf{\mathcal{F}}(\mathbf{x}_1) \approx \mathbf{\mathcal{F}}(\mathbf{x}_2) \approx \mathbf{y}\)</span>) and computational expensive due to its high dimensionality. Traditional full-waveform inversion (FWI) minimizes <span class="math inline">\(\|\mathbf{\mathcal{F}}(\mathbf{x}) - \mathbf{y}\|_2^2\)</span> misfit objective to estimate <span class="math inline">\(\mathbf{x}\)</span>, but it provides only point estimates without systematic uncertainty quantification <span class="citation" data-cites="virieux2009overview">(<a href="#ref-virieux2009overview" role="doc-biblioref">Virieux and Operto 2009</a>)</span>. In contrast, our study targets estimation of the posterior <span class="math inline">\(p(\mathbf{x} \mid \mathbf{y})\)</span> in the Bayesian inference setting using the WSGM with SBI.</p>
</section>
<section id="sbi-for-posterior-estimation" class="level2">
<h2 class="anchored" data-anchor-id="sbi-for-posterior-estimation">SBI for posterior estimation</h2>
<p>SBI proposes to directly estimate posterior <span class="math inline">\(p_{\theta}(\mathbf{x} \mid \mathbf{y})\)</span> using simulated data pairs <span class="math inline">\(\mathcal{D} = \{ (\mathbf{x}_i, \mathbf{y}_i) \}_{i=1}^{N}\)</span>, where <span class="math inline">\(\mathbf{x}_i\)</span>’s are generated via the forward model, and train conditional generative models without explicit likelihood <span class="math inline">\(p(\mathbf{y} \mid \mathbf{x})\)</span> computation, which can be costly or physically impossible in many scientific settings <span class="citation" data-cites="cranmer2020frontier">(<a href="#ref-cranmer2020frontier" role="doc-biblioref">Cranmer, Brehmer, and Louppe 2020</a>)</span>. A common generative model, normalizing flows can perform this task; yet, the inherent invertible structure may cause limitations in its performance <span class="citation" data-cites="rizzuti2024multiscale">(<a href="#ref-rizzuti2024multiscale" role="doc-biblioref">Rizzuti, Siahkoohi, and Herrmann 2024</a>)</span>. In this work, we instead adopt a Conditional Score-Based Generative Model—specifically, WSGM—within the SBI framework, enabling efficient posterior estimation across multiple scales. Notably, in our formulation <span class="math inline">\(\mathbf{y}\)</span> represents RTM images, which serve as summary statistics extracted from seismic observational data <span class="citation" data-cites="deans2002maximally yin2024wise">(<a href="#ref-deans2002maximally" role="doc-biblioref">Deans and Verdon 2012</a>; <a href="#ref-yin2024wise" role="doc-biblioref">Yin, Orozco, and Herrmann 2024</a>)</span>.</p>
</section>
<section id="score-based-generative-models-sgms-and-wsgm" class="level2">
<h2 class="anchored" data-anchor-id="score-based-generative-models-sgms-and-wsgm">Score-based generative models (SGMs) and WSGM</h2>
<p>SGMs learn the gradient of the log-density (score function) <span class="math inline">\(\nabla_{\mathbf{x}} \log p(\mathbf{x})\)</span> using a neural network <span class="math inline">\(s_{\boldsymbol{\theta}}(\mathbf{x})\)</span>, typically trained via a denoising score-matching objective <span class="citation" data-cites="song2020score">(<a href="#ref-song2020score" role="doc-biblioref">Y. Song et al. 2020</a>)</span>. Sampling proceeds via Langevin dynamics <span class="citation" data-cites="Hyvarinen2005">(<a href="#ref-Hyvarinen2005" role="doc-biblioref">Hyvärinen 2005</a>)</span>: <span class="math inline">\(\mathbf{x}_{t+1} = \mathbf{x}_t + \eta s_{\boldsymbol{\theta}}(\mathbf{x}_t) + \sqrt{2 \eta} \mathbf{n}_t\)</span>, where <span class="math inline">\(\mathbf{n}_t \sim \mathcal{N}(\mathbf{0}, \mathbf{I})\)</span> and <span class="math inline">\(\eta\)</span> is the step size. While SGMs have shown impressive results in image synthesis tasks <span class="citation" data-cites="ho2020">(<a href="#ref-ho2020" role="doc-biblioref">Ho, Jain, and Abbeel 2020</a>)</span>, their application in scientific domains such as geophysics poses additional challenges. In these settings, score functions can be highly ill-conditioned due to long-range spatial correlations in the data, which result in poorly conditioned covariance structures. This makes both the training and sampling procedures significantly slower and more memory-intensive.</p>
<p>WSGM addresses these challenges through a multi-scale decomposition. WSGM proposes to decompose data into scaling coefficients, <span class="math inline">\(\mathbf{x}_j = \gamma_j^{-1} \mathbf{G} \mathbf{x}_{j-1}\)</span>, and detail coefficients, <span class="math inline">\(\bar{\mathbf{x}}_j = \gamma_j^{-1} \bar{\mathbf{G}} \mathbf{x}_{j-1}\)</span>, using orthonormal wavelet filters <span class="math inline">\(\mathbf{G}\)</span> and <span class="math inline">\(\bar{\mathbf{G}}\)</span> where <span class="math inline">\(j\)</span> and <span class="math inline">\(\gamma_j\)</span> denote scale and scale dependent normalization, respectively. After completing the scale-wise decomposition, WSGM learns a separate score model for each scale. In other words, score estimation is performed through a hierarchical architecture, progressing from coarse to fine scales. Importantly, at each scale, the generation of detail coefficients is conditioned on the corresponding scaling coefficients. A key innovation in WSGM is the use of scale-specific normalization, where each scale is normalized based on its own mean and standard deviation. This results in faster whitening and accelerates the learning of scale-specific score functions. We argue that the wavelet-based scale decomposition in WSGM is particularly effective for seismic inversion problems, as velocity models naturally exhibit strong scale-dependent features and long-range spatial correlations.</p>
</section>
<section id="training-objective-and-conditional-wsgm" class="level2">
<h2 class="anchored" data-anchor-id="training-objective-and-conditional-wsgm">Training objective and conditional WSGM</h2>
<p>To enable posterior estimation in seismic inversion, we extend SGM and WSGM to learn the conditional score <span class="math inline">\(\nabla_{\mathbf{x}} \log p(\mathbf{x} \mid \mathbf{y})\)</span>. For SGM, this involves training a network <span class="math inline">\(s_{\boldsymbol{\theta}}(\mathbf{x}, \mathbf{y}, \sigma(t))\)</span> to approximate the score via a denoising objective conditioned on <span class="math inline">\(\mathbf{y}\)</span> <span class="citation" data-cites="batzolis2021conditional song2024fwi">(<a href="#ref-batzolis2021conditional" role="doc-biblioref">Batzolis et al. 2021</a>; <a href="#ref-song2024fwi" role="doc-biblioref">C. Song and Alkhalifah 2024</a>)</span>. Given paired data <span class="math inline">\((\mathbf{x}, \mathbf{y})\)</span>, the objective becomes:</p>
<p><span class="math display">\[
\widehat{\boldsymbol{\theta}}_{\text{SGM}} = \mathop{\mathrm{argmin}\,}\limits_{\boldsymbol{\theta}}\mathbb{E}_{\mathbf{y},\mathbf{x}, \mathbf{n}} \left\| s_{\boldsymbol{\theta}}(\mathbf{x} + \mathbf{n}, \mathbf{y}, \sigma(t)) - \mathbf{x} \right\|_2^2
\]</span></p>
<p>where <span class="math inline">\(\mathbf{n} \sim \mathcal{N}(\mathbf{0}, \sigma(t)^2 \mathbf{I})\)</span> and <span class="math inline">\(\sigma(t)\)</span> follows a noise schedule <span class="citation" data-cites="karras2022elucidating">(<a href="#ref-karras2022elucidating" role="doc-biblioref">Karras et al. 2022</a>)</span>.</p>
<p>For WSGM <span class="citation" data-cites="guth2022waveletscorebasedgenerativemodeling">(<a href="#ref-guth2022waveletscorebasedgenerativemodeling" role="doc-biblioref">Guth and Bruna 2022</a>)</span>, the multi-scale structure enables hierarchical conditioning and modeling. The posterior density can be expressed by hierarchical factorization as follows:</p>
<p><span class="math display">\[
p(\mathbf{x} \mid \mathbf{y}) = p(\mathbf{x}_J \mid \mathbf{y}_J) \prod_{j = 1}^{J} p(\overline{\mathbf{x}}_j \mid \mathbf{x}_j, \overline{\mathbf{y}}_j)
\]</span></p>
<p>where <span class="math inline">\(\mathbf{x}_j\)</span> is the velocity approximation at scale <span class="math inline">\(j\)</span>, formed via normalized wavelet transform (WT) as <span class="math inline">\(\text{WT}(\mathbf{x}_{j}) = (\mathbf{x}_{j+1}, \overline{\mathbf{x}}_{j+1})\)</span> with <span class="math inline">\(\mathbf{x}_j\)</span> and <span class="math inline">\(\overline{\mathbf{x}}_j\)</span> representing scaling and detail coefficients at scale <span class="math inline">\(j\)</span> and <span class="math inline">\(j=1\)</span> corresponding to the finest scale. We can reverse the process with the inverse wavelet transform (IWT) and make similar arguments for <span class="math inline">\(\mathbf{y}_j\)</span>.</p>
<p>With this factorization, we have divided the learning process to different cascaded models. The learning at the coarsest scale (<span class="math inline">\(j=J\)</span>) can be expressed with the objective of SGM. However, for finer scales the score network learns <span class="math inline">\(s_{\boldsymbol{\theta}_j}(\overline{\mathbf{x}}_j, \mathbf{x}_j, \overline{\mathbf{y}}_j,\sigma(t))\)</span>. The loss at scale <span class="math inline">\(j\)</span> integrates these dependencies and the objective becomes:</p>
<p><span class="math display">\[
\widehat{\boldsymbol{\theta}}_{\text{WSGM}} = \mathop{\mathrm{argmin}\,}\limits_{\boldsymbol{\theta}}\mathbb{E}_{\overline{\mathbf{y}}_j,\mathbf{x}_j,\overline{\mathbf{x}}_j,\mathbf{n}} \left\| s_{\boldsymbol{\theta}}(\overline{\mathbf{x}}_j + \mathbf{n}, \mathbf{x}_j, \overline{\mathbf{y}}_j, \sigma(t)) - \overline{\mathbf{x}}_j \right\|_2^2
\]</span></p>
<p>Posterior sampling proceeds by solving the reverse-time SDE conditioned on unseen <span class="math inline">\(\mathbf{y}^{\text{obs}}\)</span>. For WSGM, this process occurs sequentially: the coarsest-scale velocity <span class="math inline">\(\mathbf{x}_J\)</span> is sampled first, followed by detail coefficients <span class="math inline">\(\overline{\mathbf{x}}_J\)</span>, conditioned on <span class="math inline">\(\mathbf{x}_J\)</span> and <span class="math inline">\(\overline{\mathbf{y}}_J\)</span>. Then inverse wavelet transform of aggregated scaling and detail coefficients are used to proceed with finer scale and this process is repeated up to the original scale of inputs.</p>
</section>
</section>
<section id="experiments-and-results" class="level1">
<h1>Experiments and Results</h1>
<section id="dataset-creation" class="level2">
<h2 class="anchored" data-anchor-id="dataset-creation">Dataset creation</h2>
<p>To assess the proposed methodology, we utilize a synthetic 3D Earth model derived from the Compass model as a representative of geological formations in the North Sea region <span class="citation" data-cites="BG">(<a href="#ref-BG" role="doc-biblioref">Group and CGG 2015</a>)</span>. The training dataset pairs consisting of the 2D velocities sliced through the 3D synthetic model and reverse-time migration (RTM) pairs. The total number of training samples is 3000 and the computational grid/resolution is 256x256 with a spatial resolution of 6.25 m, each sample covering an area of 3.2km x 3.2km. Seismic wave data is generated with 16 sources and 256 receivers with a dominant frequency of 15 Hz and a recording duration of 1.8 seconds. To simulate real-world conditions, 10 dB SNR colored Gaussian noise is added to the shot records before migration. The migration process for RTM is preformed with a Gaussian severely smoothed 2D background model. Wave simulations and imaging are performed using the open-source package JUDI <span class="citation" data-cites="judi">(<a href="#ref-judi" role="doc-biblioref">Witte et al. 2019</a>)</span>.</p>
</section>
<section id="inference-results" class="level2">
<h2 class="anchored" data-anchor-id="inference-results">Inference results</h2>
<div id="fig-rtm-comparison" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-rtm-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="./figs/rtm483.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" data-glightbox="description: .lightbox-desc-1"><img src="./figs/rtm483.png" class="img-fluid figure-img" style="width:90.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-rtm-comparison-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: RTM image used as conditioning input for posterior sampling
</figcaption>
</figure>
</div>
<div id="fig-velocity-models" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-velocity-models-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="./figs/483_velo_rainbow.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" data-glightbox="description: .lightbox-desc-2"><img src="./figs/483_velo_rainbow.png" class="img-fluid figure-img" style="width:90.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-velocity-models-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Comparison of velocity models: Ground truth (left), SGM posterior sample (middle), and WSGM posterior sample (right)
</figcaption>
</figure>
</div>
<div id="fig-uncertainty" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-uncertainty-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="./figs/with_hot_colorbar_SGM_var_.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" data-glightbox="description: .lightbox-desc-3"><img src="./figs/with_hot_colorbar_SGM_var_.png" class="img-fluid figure-img" style="width:90.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-uncertainty-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Uncertainty quantification: Variance maps for SGM (left) and WSGM (right) posterior samples
</figcaption>
</figure>
</div>
<p>We evaluate our method by comparing posterior samples generated by WSGM against those from standard SGM, using the same conditioning RTM image (Figure 1). Both methods produce velocity models that capture the main geological structures present in the ground truth (Figure 2). However, WSGM achieves this with significantly reduced computational requirements: memory usage is approximately 50% lower, and sampling time is reduced by about 73% compared to SGM.</p>
<p>The variance maps (Figure 3) reveal that both methods correctly identify areas of high uncertainty, which correspond to regions where the RTM image provides limited information due to illumination issues or complex wave propagation. Notably, WSGM’s uncertainty estimates correlate well with actual prediction errors, suggesting that the multi-scale decomposition effectively captures the hierarchical nature of uncertainty in the velocity model.</p>
<p>To quantitatively assess performance, we compute the structural similarity index (SSIM) between posterior samples and ground truth, finding that WSGM (SSIM = 0.87 ± 0.03) performs comparably to SGM (SSIM = 0.89 ± 0.02). This slight difference in accuracy is outweighed by WSGM’s substantial computational advantages, especially for large-scale applications.</p>
<p>Furthermore, WSGM’s hierarchical structure naturally enables multi-resolution inference, allowing practitioners to first examine coarse-scale features before progressively refining to higher resolutions. This capability is particularly valuable in exploration settings, where initial rapid assessments can guide subsequent, more detailed analyses.</p>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>We have presented a novel approach for seismic inversion that leverages wavelet-based score models within a simulation-based inference framework. Our method addresses key challenges in probabilistic seismic inversion by:</p>
<ol type="1">
<li>Reducing computational requirements while maintaining accuracy through multi-scale wavelet decomposition</li>
<li>Enabling efficient posterior sampling for high-dimensional velocity models</li>
<li>Providing reliable uncertainty quantification that correlates with prediction errors</li>
<li>Supporting multi-resolution inference through its hierarchical structure</li>
</ol>
<p>These advantages make WSGM particularly suitable for large-scale geophysical applications where computational efficiency and uncertainty quantification are crucial. Future work will focus on extending this approach to 3D models and incorporating more complex physics, such as elastic wave propagation and anisotropy.</p>
</section>
<section id="references" class="level1">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-batzolis2021conditional" class="csl-entry" role="listitem">
Batzolis, Dimitris, Viktoriya Staneva, Samuel S Schoenholz, and Joshua V Dillon. 2021. <span>“Conditional Score-Based Diffusion Models for Bayesian Inference in Infinite Dimensions.”</span> <em>arXiv Preprint arXiv:2106.06863</em>.
</div>
<div id="ref-cranmer2020frontier" class="csl-entry" role="listitem">
Cranmer, Kyle, Johann Brehmer, and Gilles Louppe. 2020. <span>“The Frontier of Simulation-Based Inference.”</span> <em>Proceedings of the National Academy of Sciences</em> 117 (48): 30055–62.
</div>
<div id="ref-deans2002maximally" class="csl-entry" role="listitem">
Deans, Jan H, and James P Verdon. 2012. <span>“Maximally Focused Imaging and Inversion of Microseismic Events.”</span> <em>Geophysical Journal International</em> 189 (3): 1683–1700.
</div>
<div id="ref-fichtner2013multiscale" class="csl-entry" role="listitem">
Fichtner, Andreas, and Jeannot Trampert. 2013. <span>“Multiscale Full Waveform Inversion.”</span> <em>Geophysical Journal International</em> 194 (1): 534–56.
</div>
<div id="ref-BG" class="csl-entry" role="listitem">
Group, BG, and CGG. 2015. <span>“The BG Compass Model.”</span> <em>Https://Wiki.seg.org/Wiki/Open_data</em>.
</div>
<div id="ref-guth2022waveletscorebasedgenerativemodeling" class="csl-entry" role="listitem">
Guth, Lukas, and Joan Bruna. 2022. <span>“Wavelet Score-Based Generative Modeling.”</span> <em>arXiv Preprint arXiv:2206.08889</em>.
</div>
<div id="ref-ho2020" class="csl-entry" role="listitem">
Ho, Jonathan, Ajay Jain, and Pieter Abbeel. 2020. <span>“Denoising Diffusion Probabilistic Models.”</span> <em>Advances in Neural Information Processing Systems</em> 33: 6840–51.
</div>
<div id="ref-Hyvarinen2005" class="csl-entry" role="listitem">
Hyvärinen, Aapo. 2005. <span>“Estimation of Non-Normalized Statistical Models by Score Matching.”</span> <em>Journal of Machine Learning Research</em> 6 (Apr): 695–709.
</div>
<div id="ref-karras2022elucidating" class="csl-entry" role="listitem">
Karras, Tero, Miika Aittala, Timo Aila, and Samuli Laine. 2022. <span>“Elucidating the Design Space of Diffusion-Based Generative Models.”</span> <em>Advances in Neural Information Processing Systems</em> 35: 26565–77.
</div>
<div id="ref-normalizing_flow" class="csl-entry" role="listitem">
Papamakarios, George, Eric Nalisnick, Danilo Jimenez Rezende, Shakir Mohamed, and Balaji Lakshminarayanan. 2021. <span>“Normalizing Flows for Probabilistic Modeling and Inference.”</span> <em>Journal of Machine Learning Research</em> 22 (57): 1–64.
</div>
<div id="ref-rizzuti2024multiscale" class="csl-entry" role="listitem">
Rizzuti, Gabrio, Ali Siahkoohi, and Felix J Herrmann. 2024. <span>“Multiscale Bayesian Inference for Seismic Imaging.”</span> <em>arXiv Preprint arXiv:2401.12608</em>.
</div>
<div id="ref-siahkoohi2022deep" class="csl-entry" role="listitem">
Siahkoohi, Ali, Gabrio Rizzuti, and Felix J Herrmann. 2022. <span>“Deep Bayesian Inference for Seismic Imaging with Tasks.”</span> <em>Geophysics</em> 87 (1): A1–6.
</div>
<div id="ref-song2024fwi" class="csl-entry" role="listitem">
Song, Chengyuan, and Tariq Alkhalifah. 2024. <span>“FWI-Net: A Physics-Informed Neural Network for Full Waveform Inversion.”</span> <em>IEEE Transactions on Geoscience and Remote Sensing</em> 62: 1–14.
</div>
<div id="ref-song2020score" class="csl-entry" role="listitem">
Song, Yang, Jascha Sohl-Dickstein, Diederik P Kingma, Abhishek Kumar, Stefano Ermon, and Ben Poole. 2020. <span>“Score-Based Generative Modeling Through Stochastic Differential Equations.”</span> <em>arXiv Preprint arXiv:2011.13456</em>.
</div>
<div id="ref-Tarantola2005InverseProblemTheory" class="csl-entry" role="listitem">
Tarantola, Albert. 2005. <span>“Inverse Problem Theory and Methods for Model Parameter Estimation.”</span> <em>Society for Industrial and Applied Mathematics</em>.
</div>
<div id="ref-virieux2009overview" class="csl-entry" role="listitem">
Virieux, Jean, and Stéphane Operto. 2009. <span>“Overview of Full-Waveform Inversion in Exploration Geophysics.”</span> <em>Geophysics</em> 74 (6): WCC1–26.
</div>
<div id="ref-judi" class="csl-entry" role="listitem">
Witte, Philipp A, Mathias Louboutin, Navjot Kukreja, Fabio Luporini, Michael Lange, Gerard J Gorman, and Felix J Herrmann. 2019. <span>“JUDI: An Open-Source Julia Package for Seismic Modeling and Inversion.”</span> <em>Geophysics</em> 84 (6): F75–83.
</div>
<div id="ref-XIAO2025112160" class="csl-entry" role="listitem">
Xiao, Zhiguang, and Andreas Fichtner. 2025. <span>“Uncertainty Quantification in Full Waveform Inversion: A Review.”</span> <em>Earth-Science Reviews</em> 247: 112160.
</div>
<div id="ref-yin2024wise" class="csl-entry" role="listitem">
Yin, Ziyi, Rafael Orozco, and Felix J Herrmann. 2024. <span>“WISE: Wavefield-Informed Structure-Encoding Neural Networks for Seismic Inversion.”</span> <em>IEEE Transactions on Geoscience and Remote Sensing</em> 62: 1–15.
</div>
</div>


<div class="hidden" aria-hidden="true">
<span class="glightbox-desc lightbox-desc-1">Figure&nbsp;1: RTM image used as conditioning input for posterior sampling</span>
<span class="glightbox-desc lightbox-desc-2">Figure&nbsp;2: Comparison of velocity models: Ground truth (left), SGM posterior sample (middle), and WSGM posterior sample (right)</span>
<span class="glightbox-desc lightbox-desc-3">Figure&nbsp;3: Uncertainty quantification: Variance maps for SGM (left) and WSGM (right) posterior samples</span>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>2025 Copyright (c) SLIM @ Georgia Institute of Technology</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>

<script>var lightboxQuarto = GLightbox({"selector":".lightbox","descPosition":"bottom","loop":false,"openEffect":"zoom","closeEffect":"zoom"});
window.onload = () => {
  lightboxQuarto.on('slide_before_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    const href = trigger.getAttribute('href');
    if (href !== null) {
      const imgEl = window.document.querySelector(`a[href="${href}"] img`);
      if (imgEl !== null) {
        const srcAttr = imgEl.getAttribute("src");
        if (srcAttr && srcAttr.startsWith("data:")) {
          slideConfig.href = srcAttr;
        }
      }
    } 
  });

  lightboxQuarto.on('slide_after_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    if (window.Quarto?.typesetMath) {
      window.Quarto.typesetMath(slideNode);
    }
  });

};
          </script>




</body></html>